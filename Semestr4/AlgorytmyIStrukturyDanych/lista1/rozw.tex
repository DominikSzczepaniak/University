\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{amsfonts}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}	% podłoga
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}		% sufit
\newcommand{\fractional}[1]{\left\{ #1 \right\}}		% część ułamkowa {x}
\newcommand{\abs}[1]{\left| #1 \right|}					% wartosc bezwzgledna / moc
\newcommand{\set}[1]{\left \{ #1 \right \}}				% zbiór elementów {a,b,c}
\newcommand{\pair}[1]{\left( #1 \right)}				% para elementów (a,b
\title{AISD lista 1}
\author{Dominik Szczepaniak}
\begin{document}

\maketitle

\bgroup\obeylines

\section{Zadanie 1}
Zakładam, że T jest podane jako 
struct Node{
    Node l = null;
    Node r = null;
    int value;
};

wpp. powyzsze zadanie nie ma troche sensu

a)
Chcemy to zrobic rekurencyjnie wiec:
int ile_wierzcholkow(Node t){
    if(t == null){
        return 1;
    }
    return ile_wierzcholkow(t.l) + ile_wierzcholkow(t.r) + 1;
}

Dlaczego to działa? Musimy wziąć siebie oraz wynik dla naszych synów. Jeśli nasi synowie są liścmi to zwrócimy po prostu 1, a w.p.p obliczymy rekurencyjnie wyniki dla naszych synów oraz jeszcze dodamy do tego siebie samego (+1).

b)
Jakie mamy możliwości najdłuższych odległości?
1. Najdłuższa droga to najgłębszy syn z lewego poddrzewa i najgłębszy syn z prawego poddrzewa od obecnego wierzchołka. Wtedy odległość to suma głębokości. 

Dlaczego? Jeśli tak nie jest to inaczej najdłuższa droga będzie po prostu ścieżka poziom po poziomie w dół. Więc w szczególności będzie to też dawać odpowiedź, bo możemy wziąć wierzchołek w którym byśmy zaczęli tą ścieżkę i obliczyli max_depth(t.l), a max_depth(t.r) = 0. Ale! Niech d będzie długością ścieżki. Jeśli max_depth(t.l) == d, a max_depth(t.r) > 0, to mamy najdłuższą drogę w lewym i prawym poddrzewie zakładanego wierzchołka.

int max_depth(Node t){
    if(t == null){
        return 0
    }
    left = max_depth(t.l)
    right = max_depth(t.r)
    return max(left, right) + 1;
}

int najwieksza_odleglosc(Node t){
    if(t == null){
        return 0;
    }
    lewo = max_depth(t.l)
    prawo = max_depth(t.r)
    wynik = lewo + prawo + 1;
    return max(wynik, max(najwieksza_odleglosc(t.l), najwieksza_odleglosc(t.r)));
}

\section{Zadanie 3}
Dobra, jak robimy w ogóle topology sort? Jakie są znane algorytmy? 
1. Algorytm Kahn'a 
L <- lista po topo sorcie 
S <- zbiór wierzchołków bez wchodzącej krawędzi

while S is not empty:
    remove node n from S
    add n to L 
    foreach node m with edge e from n to m:
        remove edge e from graph 
        if m has no incoming edges:
            add m to S 

if graph has edges:
    return error 
else 
    return L 
    

Jak zmodyfikować, żeby dawał porządek topologiczny? Wystarczy z S zawsze brać najmniejszy wartościowo Node aby zmniejszyć porządek topologiczny. 

Czyli nasz S musi być zbiorem który wyrzuca liczby minimalne na samą górę. Można to po prostu zrobić kopcem, ale to też zależy od implementacji zbioru w różnych językach np. w C++ bazowo set jest już kopcem minimalnym, więc wystarczy brać pierwszy element z S i jest to minimalny element. 
No ale nie działamy w języku, więc po prostu niech S będzie kopcem minimalnym. Szybkość operacji się nie zmienia, po prostu jest dalej log(n)

Złożoność O(nlogn + m)

Czy da się lepiej? Nie. Druga opcja na topo sort to DFS, który dizała w O(n + m), ale usimy pamiętać wierzchołki też za pomocą kopca (multiset/priority_queue), więc będzie ta sama złożoność.


\section{Zadanie 4}
Dobra pierwsze co mozna zrobic takiego podstawowego to jest dijkstra z wierzchołka v który znajdzie nam najkrótszą trase do kazdego innego wierzcholka.
Pozniej robimy sobie dp z bfs jednoczesnie:

fn dfs(u: vertex) {
    visited[u] = true;  
    for x: vecter in u:
        if D[x] < D[u]:
            if !visited[x]:
                dfs(x);
            dp[u] <- dp[u] + dp[x];
}
dp[v] = 1;
dfs(u)
println!("{}", dp[u]);

O(E * log(V) + V+E) 

\section{Zadanie 5}
dp[node] - (długość najdłuższej scieżki która zaczyna się w node, ojciec)
długość ścieżki albo można przedłużyć z sąsiada albo jest już najdłuższa

dla przykladu:
a -> 3 -> 2
|
4 - 5 - 6 - 7 
|
1

tutaj a wykona dfs na 3 i 4, te wykonaja glebiej. po skonczonym dfs wezmiemy najdluzsza odnoge i zaznaczymy ze ojcem tej odnogi jest a 

use std::io::{self, BufRead};
use std::cmp::max;

fn dfs(node: usize, dp: &mut Vec<(u32, u32)>, adj: &Vec<Vec<usize>>, visited: &mut Vec<bool>) {
    visited[node] = true;
    for &i in &adj[node] {
        if !visited[i] {
            dfs(i, dp, adj, visited);
            if 1 + dp[i].0 > dp[node].0{
                dp[node].0 = 1 + dp[i].0;
                dp[node].1 = i as u32;
            }
        }
    }
}

fn main() {
    let stdin = io::stdin();
    let mut handle = stdin.lock();
    let mut input = String::new();
    handle.read_line(&mut input).unwrap();
    let mut iter = input.split_whitespace();
    let n: usize = iter.next().unwrap().parse().unwrap();
    let m: usize = iter.next().unwrap().parse().unwrap();
    let mut visited = vec![false; n + 1];
    let mut adj = vec![vec![]; n + 1];
    let mut dp: Vec<(u32, u32)> = vec![(0, 0); n + 1];
    for _i in 1..=m {
        input.clear();
        handle.read_line(&mut input).unwrap();
        let mut iter = input.split_whitespace();
        let a: usize = iter.next().unwrap().parse().unwrap();
        let b: usize = iter.next().unwrap().parse().unwrap();
        adj[a].push(b);
    }

    for i in 1..=n {
        if !visited[i] {
            dfs(i, &mut dp, &adj, &mut visited);
        }
    }
    let mut ans = 0;
    let mut ktory = 0;
    for i in 1..=n {
        if dp[i].0 > ans {
            ans = dp[i].0;
            ktory = i;
        }
    }
    println!("{}", ans);
    let mut res = vec![];
    while ktory != 0 {
        res.push(ktory);
        ktory = dp[ktory].1 as usize;
    }
    res = res.into_iter().rev().collect();
    for i in (0..res.len()).rev() {
        print!("{} ", res[i]);
    }
}

Dlaczego działa?
Jeśli mamy wszystkich synów jakiegoś Node 1, to chcemy wybrać ten który ma najdłuższą drogę. Zapisujemy najdłuższą drogę w dp, więc wystarczy sprawdzić dp[syn] + 1 (odległość z 1 do syna). 
najdłuższą ścieżke przypisujemy do drugiej wartości, zeby pamietac dokad sie szlo (na koncu to odwrocimy)


\section{Zadanie 6}
Mozemy usuwac tylko parami, wiec w najlepszej opcji usuniemy dokladnie polowe par z tablicy.
Zauwazmy tez ze mamy nastepujaca obserwacje:
Jesli a_i moze wykreslic a_j, to a_i moze wykreslic a_j+1, a_j+2, ..., a_n - bo tablica jest posortowana.
W takim razie zrobmy sobie dwa wskazniki. Niech jeden wskazuje poczatek tablicy, a drugi pierwszy element po srodku.


Przeprowadzamy nastepujacy algorytm:
Jesli mozna wykreslic wartosc z 1 wskaznika i drugiego to wykreslamy obie (dodajemy 1 do wyniku i zwiekszamy wskazniki o 1)
Jesli nie mozna wykreslic, bo wartosc 2 wskaznika jest za mala, to przesuwamy drugi wskaznik.


Dlaczego dostaniemy najlepsza mozliwa odpowiedz?
Jesli a_i nie moze wykreslic a_j, to w szczegolnosci a_i+1 nie moze wykreslic a_j (bo jest wieksze), wiec a_j nie moze wykreslic nic, co juz nie zostalo wykreslone. (Jesli np. a_i-1 moglo wykreslic a_j, ale wykreslilo a_j-1, to a_i nie wykresli a_j-1, wiec wynik jest ten sam).
W takim razie wykreslimy najlepszy mozliwy wynik.


Załóżmy, że jest para <a, b> która nie zostanie wykreślona, a może być (czyli b >= 2a)
Mamy takie przypadki:
1. a i b są w lewej tablicy:
Skoro b jest w lewej tablicy to w prawej sa liczby wieksze od b czyli tez mozliwe do wykreslenia z a - czyli a zostanie wykreslona
2. a w lewej b w prawej:
jeśli na lewo od a jest wiecej liczb niz na lewo od b to b zostanie wykreslone (bo liczby po lewo od a sa mniejsze, wiec b moze byc z nimi wykreslone) 

jeśli na lewo od a jest mniej liczb niż na lewo od b 
to wykreślimy albo a albo b albo oba - czyli nie będzie tej pary 
// 1 3 4 4 4 4 4 6 - oba
//   a           b  

// 1 2 3 4 5 6 7 8 - wykreślone a z nie-b 
//   a         b 
// 1 5 
// 2 6 

// 5 6 7 8| 9 9 14 15 - wykreślone b z nie-a 
//   a           b 
3. oba w prawej:
wszystkie liczby z lewej tablicy mozna wykreslic z b, wiec b zostanie wykreslone


z każdego dostajemy sprzeczność, więc dowód działa

\section{Zadanie 7}
1. Liczymy floyem warshallem wszystkie najkrotsze sciezki dla grafu bez wszystkich v1, v2, ..., vk O(n^3)
disty na inf 
disty do samych siebie na 0 
i jazda to:
For k = 0 to n – 1
For i = 0 to n – 1
For j = 0 to n – 1
Distance[i, j] = min(Distance[i, j], Distance[i, k] + Distance[k, j])

where i = source Node, j = Destination Node, k = Intermediate Node


Mozemy isc od tylu i zamiast usuwac bedziemy dodawac.
Jak dodajemy nowy wierzcholek u to musimy obliczyc odleglosci (v, u) dla kazdego v. Teraz mozemy po prostu zaktualizowac odleglosci do starych wierzcholkow jako:
(x, y) = (x, u) + (u, y)
Odleglosci zapisujemy w 2 wymiarowym wektorze

Obliczanie odleglosci (v, u) jest w O(n+m)
Dla kzdego wierzcholka to jest O(n*(n+m))

Pozniej liczenie nowych odleglosci bedzie O(n^2) dla kazdego czyli O(n^3)
Liczenie D_j też O(n^2) i dla kazdego wierzcholka n razy czyli O(n^3)


Takze mamy O(n^3)

1. Liczymy floyem warshallem wszystkie najkrotsze sciezki dla grafu bez wszystkich v1, v2, ..., vk O(n^3)
2. Obliczanie odleglosci (v, u) dla kazdego nowego v O(n*(n+m))
3. Update odległosci O(n^3)
4. Liczenie D_j O(n^3)

\section{Zadanie 8}
Pomysly:
1. Binsearch po r 
2. Trzymanie jakiejs tablicy wystapien liczb i dodawanie na sumach prefiksowych 
Czyli jak mamy listy:
1 3 4
1 2 5
1 5 7
1 2 3


To glowna lista:
1 2 3 4  5  7
4 6 8 9 11 12

Oczywiscie nie zapisujemy jako wartosci liczb tylko sobie mapujemy na 1, 2, 3, ..., k*n 

musimy znalezc teraz r taki, ze roznica bedzie rowna ilosc list. W tym przypadku wystarczy 1
r mozna tu znalezc binarnie (zamortyzuje sie)
zlozonosc i tak jest k*n wiec potencjalnie to działa dosc dobrze


Jak zrobic binsearch na tym?
1. Dla kazdego elementu mozna robic binsearch O(n*k*log(nk))

2. Nie robic binsearcha i gasieniczke zrobic? O(n*k) - raczej nie wyjdzie


Zauważmy, że jeśli mamy kopie elementów w poszczególnych listach to są one zbędne.
(
Sortujemy kazda liste O(knlog(kn))
Wrzucamy wszystko do jednej listy (usuwajac kopie z pojedynczych list (przejscie forem)) O(kn)
Sortujemy cała dużą liste O(knlog(kn))
)
Z tej tablicy robimy nowa tablice ktora ma pary <liczba, ilosc wystapien> O(kn)
bedziemy sobie mapowac wartosci na 1,2,3,...,kn - jeśli element jest na k-tym miejscu to odnosimy sie do tablicy z poprzedniego podpunktu [k].
Robimy na tym sumy prefiksowe  O(kn)
Pozniej dla kazdego miejsca szukamy sobie binsearchem jak bardzo mozna sie rozszerzyc i sprawdzamy min r za każdym razem (jednoczesnie odmapowujac liczby) O(knlog(kn))
Czyli jeśli mamy sumy np.
sumy[end] - sumy[i-1] <= k to r jest rowne tablica_liczb[end].0 - tablica_liczb[i].0 -> r minimalizujemy, wiec robimy min na jakiejs tam zmiennej


\egroup
\end{document}