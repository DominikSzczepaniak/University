Worker.prototype = Person.prototype; //Wadą takiego podejścia jest to, że oba prototypy (Worker.prototype i Person.prototype) wskazywałyby na ten sam obiekt. Zmiany dokonane na Worker.prototype spowodowałyby zmiany również w Person.prototype, co może prowadzić do niepożądanych efektów ubocznych. Każda zmiana w prototypie Worker mogłaby wpływać na działanie innych konstruktorów (np. Person), co jest niepożądane przy tworzeniu oddzielnych hierarchii dziedziczenia.
Worker.prototype = new Person(); //Ten sposób wywołuje konstruktor Person, tworząc instancję Person jako prototyp dla Worker. To wprowadza ryzyko zmian w instancji Person poprzez wprowadzenie zmian do prototypu Worker, co może prowadzić do nieoczekiwanych zachowań i złamanie hermetyzacji danych. Ponadto, ten sposób tworzy właściwości instancji Person jako właściwości prototypu Worker, co nie jest intencją dziedziczenia, a jedynie udostępnianiem ich przez prototyp Worker.

Worker.prototype = Object.create(Person.prototype);//Object.create tworzy nowy obiekt, który ma podanego prototypu. Ustawiając Worker.prototype na nowy obiekt utworzony z Person.prototype, zachowujemy oddzielne łańcuchy prototypów dla Worker i Person. Dzięki temu zmiany wprowadzane w Worker.prototype nie wpłyną bezpośrednio na Person.prototype. Równocześnie Worker będzie dziedziczył cechy od Person, co odzwierciedla relację dziedziczenia.